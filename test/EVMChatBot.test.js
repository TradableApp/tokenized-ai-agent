// test/EVMChatBot.test.js
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("EVMChatBot", function () {
  let EVMChatBot, chatBot;
  let deployer, user, oracle, unauthorizedUser;

  // Mock data for testing. In a real scenario, this would be generated by the client.
  const domain = "example.com";
  const roflAppID = ethers.zeroPadBytes("0x", 21);
  const mockEncryptedContent = ethers.toUtf8Bytes("encrypted-prompt-content");
  const mockUserKey = ethers.toUtf8Bytes("user-encrypted-key");
  const mockRoflKey = ethers.toUtf8Bytes("rofl-encrypted-key");
  const mockAnswerContent = ethers.toUtf8Bytes("encrypted-answer-content");

  beforeEach(async function () {
    [deployer, user, oracle, unauthorizedUser] = await ethers.getSigners();
    EVMChatBot = await ethers.getContractFactory("EVMChatBot");
    chatBot = await EVMChatBot.deploy(domain, roflAppID, oracle.address);
    await chatBot.waitForDeployment();
  });

  it("should set the correct initial state on deployment", async function () {
    // The `chatBot` instance was deployed in the `beforeEach` block.
    // We just need to check its public variables.
    expect(await chatBot.oracle()).to.equal(oracle.address);
    expect(await chatBot.domain()).to.equal(domain);
    expect(await chatBot.roflAppID()).to.equal(roflAppID);
  });

  it("should append a prompt with encrypted data", async function () {
    const chatBotWithUser = chatBot.connect(user);
    await chatBotWithUser.appendPrompt(mockEncryptedContent, mockUserKey, mockRoflKey);

    const prompts = await chatBotWithUser.getPrompts(user.address);
    expect(prompts.length).to.equal(1);
    // Check that the stored data matches the encrypted bytes we sent.
    expect(prompts[0].encryptedContent).to.equal(ethers.hexlify(mockEncryptedContent));
    expect(prompts[0].userEncryptedKey).to.equal(ethers.hexlify(mockUserKey));
    expect(prompts[0].roflEncryptedKey).to.equal(ethers.hexlify(mockRoflKey));
  });

  it("should allow the oracle to view prompts and answers", async function () {
    const chatBotWithUser = chatBot.connect(user);
    await chatBotWithUser.appendPrompt(mockEncryptedContent, mockUserKey, mockRoflKey);

    // Connect as the oracle and try to view the user's data.
    const chatBotWithOracle = chatBot.connect(oracle);

    // This should NOT revert.
    const prompts = await chatBotWithOracle.getPrompts(user.address);
    expect(prompts.length).to.equal(1);

    const answers = await chatBotWithOracle.getAnswers(user.address);
    expect(answers.length).to.equal(0); // No answers yet, but the call should succeed.
  });

  it("should revert if an unauthorized user tries to submit an answer", async function () {
    const chatBotWithUser = chatBot.connect(user);
    await chatBotWithUser.appendPrompt(mockEncryptedContent, mockUserKey, mockRoflKey);

    // Connect as a different, unauthorized user and try to submit an answer.
    const chatBotWithUnauthorized = chatBot.connect(unauthorizedUser);

    await expect(
      chatBotWithUnauthorized.submitAnswer(
        mockAnswerContent,
        mockUserKey,
        mockRoflKey,
        0,
        user.address,
      ),
    ).to.be.revertedWithCustomError(chatBot, "UnauthorizedOracle");
  });

  it("should clear prompts and answers", async function () {
    const chatBotWithUser = chatBot.connect(user);
    await chatBotWithUser.appendPrompt(mockEncryptedContent, mockUserKey, mockRoflKey);
    await chatBotWithUser.clearPrompt();

    const prompts = await chatBotWithUser.getPrompts(user.address);
    const answers = await chatBotWithUser.getAnswers(user.address);
    expect(prompts.length).to.equal(0);
    expect(answers.length).to.equal(0);
  });

  it("should submit an answer and reject a duplicate answer", async function () {
    const chatBotWithUser = chatBot.connect(user);
    await chatBotWithUser.appendPrompt(mockEncryptedContent, mockUserKey, mockRoflKey);

    const chatBotWithOracle = chatBot.connect(oracle);
    // The oracle submits an encrypted answer for prompt ID 0 for the user.
    await chatBotWithOracle.submitAnswer(
      mockAnswerContent,
      mockUserKey,
      mockRoflKey,
      0,
      user.address,
    );

    const answers = await chatBotWithUser.getAnswers(user.address);
    expect(answers.length).to.equal(1);
    expect(answers[0].promptId).to.equal(0);
    // Check that the nested message struct contains the correct encrypted data.
    expect(answers[0].message.encryptedContent).to.equal(ethers.hexlify(mockAnswerContent));

    // The oracle attempts to answer the same prompt again.
    await expect(
      chatBotWithOracle.submitAnswer(mockAnswerContent, mockUserKey, mockRoflKey, 0, user.address),
    ).to.be.revertedWithCustomError(chatBot, "PromptAlreadyAnswered");
  });

  it("should revert unauthorized access to view functions", async function () {
    // An unauthorized user tries to view prompts belonging to `user`.
    await expect(
      chatBot.connect(unauthorizedUser).getPrompts(user.address),
    ).to.be.revertedWithCustomError(chatBot, "UnauthorizedUserOrOracle");
  });
});
